#### 类和对象



抽象的概念。

>类：类是模板，，相当于C中的自定义类型。
>
>对象：是实例化的个体。通过一个类，可以产生多个对象。
>
>面向对象：OOP编程：java和C++编程，找到对象、创建对象、使用对象。



OOA（面向对象分析）、OOD（面向对象设计）、OOP（面向对象编程）



面向过程：把大象放进冰箱的三步。

面向对象：打开冰箱，存储，关闭都是对冰箱的操作，是冰箱的行为。冰箱就是一个对象，只要是操作冰箱所具备的功能，都要定义在冰箱中。



> 在面向对象定义中，规定了一些基本的特征：
>
> - [x] 封装：保护内部的操作不被破坏。  --- 个人理解，就是只提供接口。
> - [ ] 继承：在原本基础之上继续进行扩充
> - [ ] 多态：在一个指定的范围之内进行概念的转换。



> 类名，开头要大写



* 两种实例化对象的方法

```java
class Students{
    String name;
    int age;
}
public class Main{
    public static void main(String[] args){
        //first
        Students student = new Students;//直接在栈区和堆区，开辟空间
        
        //second
        Students student2;//先在栈区
        student2 = new Students;//在堆区。
        
    }
}
```





* 访问实例化对象的成员变量和方法

```java
 System.out.println(person1.age);//没有初始化的成员变量，会被初始化成0，可以在class中初始化。不推荐。
 person1.age = 100;//因为，可以在main中赋值。
```



```java
class Person{
    private String Students;
    private int age;
    
    public void eat(){
        sout;
    }
}
```



```java
//访问对象中的静态变量，是如何访问对象中的静态的数据成员。
System.out.println(Person.size);//调用类中的方法
person1.name = "why";
person1.age = 23;
person1.eat();

 person1.staticMethod();Person.staticMethod();
```



* 创建的类的默认的初始化

> //实例成员没有初始化  默认值为对应的0值 。引用类型默认为null 简单类型默认为0
>     //char -> '\u0000'               boolean -> false

> null在Java中为“空引用”，表示不引用任何对象。类似于C语言中的空指针。如果对null进行`.`操作会引起异常。



* 静态成员变量开辟内存的位置node1.next = node2;

```java
  //静态成员变量（static修饰的）    不属于对象  属于类  在方法区（内存）
    
    public static int size = 10;//不初始化，默认值依然为0值。
    public static int size2;//不初始化，默认值依然为0值。
```



* 创建类的方法中的局部变量内存开辟位置

```java
 public  void eat(){//可以使用static了，放在public class之外。介绍说没有static
        int a = 10;//局部变量   必须初始化。因为初始化的化在栈上。stack
        System.out.println("eat food");
        System.out.println("name is " +name +" , age is " + age);//方法
    }
```



> 解释：
>
> - [ ] 一个Java文件中只能有一个public class类，一个包中能有多个class文件。
> - [ ]  //字段 -> 成员变量    定义在方法外面  类的里面。 不太理解。
> - [ ]  类名不能相同,可以创建`public class Math`,`class Math`.但不能创建相同的类名。
>
> 类的创建，位置，在`public class外，（也可以叫做，接口类）
>
> 类的组成部分，分为字段和方法
>
> 其中的字段和方法，都可以加入修饰限定符，相关的知识是，java的特性，封装。
>
> 在IDEA中，类的创建接口的快捷键是，alt+ insert（或alt + F12,看操作系统）。









* new关键字

> 堆内存：通过new来创建分配内存空间。
>      栈内存：保存的是堆内存的地址，简单理解为保存对象的名字。
>      关键字new的主要功能是分配内存空间。
>     引用数据类型，就要使用关键字new来分配空间。





* 访问修饰限定符：

  public：                共有的

  private:                 私有的

  protected:        受保护的

  什么都不写：默认权限 --> 包访问权限  
  
* public   公开的，在这个类之外，也可以使用。隐患：会被人修改字段名。闲着没事。

* 

*  1. public   公开的，在这个类之外，也可以使用。隐患：会被人修改字段名。闲着没事。叫做接口类。
   1. private  对比public私有的，仅能在该类内部使用的字段或者方法。就是专业一点叫，访问
   






> 字段、属性、成员变量。三者等价。称呼为字段吧！



> static是静态的。有什么作用？
>
> 在类中使用static创建的字段和方法，可以通过类名访问，不需要实例化对象。相当于Math.sqrt();
>
> 在内存中开辟的位置是，方法区。
>
> 在创建的类中，对于static静态方法内部，不能用来访问，动态的（就是没有static修饰的）,动态谁的不好，是实例化的
>
> 取静态的字段++，有新new对象后，不会初始化为0.



> 使用. 访问对象的字段
>
> 访问既包含读，也包含写。
>







还学了static,并对之前的main方法中只能添加static修饰的方法，做了解释。

现在明白了,static 的使用，   静态的变量和方法，在方法区开辟内存。

```java
public class Main(){
    public static void fun1(){
        
    }
    public void fun2(){//这样的话，直接加上static修饰就好了。
        
    }
    public static void main(String[] args){
        fun1();
        fun2();
        Main m = new Main();
        m.fun2();
    }
}
```

> 关键字：static 
>
> 同一个类的不同实例共用同一个静态属性。???  这是还没学过的多态吧！！！



> 静态数据  1. 只有一份。且存在于方法区。2. 非静态的数据成员属于对象在堆上。



* public 和 pirvate修饰限定符的使用，关于java特性封装的特性
  * 在class中，使用this关键字

```java
class Student{  
    private String name;
    private int age;

    //提供一个公开的接口
    public String getName() {
        return name;
    }
    //快捷键   alt + insert    
    public void setName(String name) {
        //加this的好处。
        this.name = name;//如果不加this修饰的话，**类**中的name就不会被修改了，只能是null。
    }

    public void setAge(int age) {
        this.age = age;//接上面的，不加this.修饰的话，自己给自己赋值，没有赋值属性，依据的话，局部变量优先的原则。
    }

    public int getAge() {
        return age;
    }

    private void show(){
        //this   指向当前对象的方法或字段。无论是否私有pulic || private
        System.out.println("My name is " + this.name+".age is "+ this.age);
    }
    
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                "design'" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
* 上面的是类的创建者
* 下面的是类的调用者
* */
public class TestDemo2 {
    public static void main(String[] args) {
        Student student = new Student();
        System.out.println(student.getAge());
        student.setName("why");
        System.out.println(student.getName());
        System.out.println(student.toString());
//        System.out.println(student.show());//设置成私有的了。
//        提供的接口明白了。就是public处理的方法(),还多么高大上。
    }
}

```





> @Override    
>
> 重新  实现了一下  Object类的  toString()方法。
> 看原码
> Object   是  所有类的父类。
> 注解：这个注解指的是  这个方法是重新写的





***

##### 构造方法

提出问题：一个**对象**的产生，分为两步，是如何产生的？

1. 为对象分配内存。

2. 调用合适的构造方法

   只有完成上面的两步，类的对象才会被创建出来。this.指向的是当前对象的引用，不是对象。

> 构造方法的创建是，提供**接口**。

构造方法：其方法名是和类名相同的，且没有返回值的。

```java
//class
class Students{
    String name;
    int age;
    public Students(){
        //构造方法
    }
}
public class Main{
    public static void main(String[] args){
        Students student1 = new Students();//调用构造函数。
        System.out.println("hello");
    }
}
```

   

* 解释：合适的构造方法，表示构造方法，不知一个。

```java
class Students{
    int first;
    String namg;
    public Students(){
        
    }
    public Students(int a){
        
    }
    public Students(int a,String name){
        
    }
}
```



> 1. 当没有提供构造方法的时候，那么编译器会自动提供一个，不带有参数的构造方法。
> 2. 当手动输入一个构造方法的话，编译器就不会自动生成一个构造方法了。





```java
class Students{
    String name;
    int age;
    public Students(String j,int s){
        //有这个构造方法的话，下面调用的话才不会报错。
    }
    public Students(){
        //单纯是这个构造方法的话，下面调用的话，会报错。
    }
}

//下面是main方法
Math num = new Math("why",1);//只有在类中创建，一个构造方法的时候，并且是带有参数的时候，才会不抛出异常
//Math num = new Math();//随便都不会报错。
```





> 生成构造方法的，快捷键alt+insert,  选Constructor.





this关键字代表对象，这句话错了。

理由：this可以被用在构造方法中，这是对象还没有被创建完。



this关键字的使用：

this()  : 调用自己的构造方法。

this().data  : 调用当前对象的属性

this().func() : 调用当前对象的方法

```java
class Students{
    String name;
    int age;
    
    public void setAge(int age){
        this.age = age;
    }
    public String getName(){
        return name;//加上this也是返回的设定的值。
    }
    public Students(){
        this(why,23);//在一个构造方法中调用两个参数的构造方法。
        this(why);//只能调用一个。
        System.out.println("hello");
        this(why,23);//会报错，只能放在第一行。
    }
    public Students(String n,int a){
        
    }
    public Students(String n){
        
    }
    
    public void eat(){
        this("why",23);//this(),不能在方法里头使用。
        System.out.println(this.getName());
        System.out.println(this.age);
    }
}
```

> 习惯使用this



构造方法支持重载

原因：定义，方法名相同，参数列表不同，返回值不同；在同一个类中。

###### 代码块

1. 实例代码块/构造代码块
2. 静态代码块
3. 本地代码块，没有意义。

```java
class Students{
    String name;
    int age;
    
    {
        //实例代码块
        this.name ="why";
        System.out.println("实例代码块…………")；
    }
    
    static{
        //静态代码块
        //this.name = "why";//err
        System.out.println("静态代码块…………");
    }
    
    public void eat(){
        {
            //本地代码块
        }
    }
}
```



> 先后顺序：
>
> 1. 显示静态的，后实例化的，在构造方法。
>
> 2. 如果是相同的，比如：两个静态的，会根据顺序结构，（ps：可能是会变量，方法在java编译的过程中，提升，想js中的一样）
> 3. 静态的只能放静态的变量。
> 4. 静态的代码块只能打印一次，new 开辟空间两次。静态变量也是如此。是最早被执行的。
>
> 5. 通过类名来访问静态变量，
>
>    如果静态方法里， 访问了实例成员变量，那么 这个实例成员是依赖对象的。但静态方法不依赖。就是实例化的对象还没出生。





###### 匿名对象

只能使用一次的对象

```java
public class void main(String[] args){
    Students student1 = new Students();//实例化对象。
    
    
     new Students().eat();//匿名对象
}
```

