## 数据结构

### 1.线性表

线性表，（linear list)是n个具有相同特性的数据元素的有限数列。

* 常见的线性表：

  **顺序表**、链表、栈、队列、字符串……

线性表在逻辑上是线性的结构，是一条连续的直线。但是物理结构不一定是连续的。

顺序表：一个数组。

链表：1.不带头节点的单向的非循环链表。

2. 不带头节点的双向非循环链表。

数据结构：数据+结构。          组织数据的方式。 考察逻辑性。

##### 1.1顺序表

顺序表，逻辑的底层是一个数组，但又不单单是数组。







#### 抛出异常

```java
throw new RuntimeException("抛出异常");
```





### 顺序表

```java
class Students{
    
}
public class MyArraysList {
    public int[] elem;
//    public Students elem0;
    public int usedSize;
    public static final int capacity = 10;

    public MyArraysList(){
        this.elem = new int[capacity];
        this.usedSize = 0;//计数器
    }
```

> 顺序表的创建，可以创建整型数组、char类型、和自定义类型的数组。
>
> 和C中的自定义通讯录差不多吧！！

> 一些接口的实现，只要主义usedSize  和this.usedSize - 1的区别就行了。









```


import java.util.Arrays;

/**
 * @anthor : why
 * @date : 2022/5/26 20:22
 * @description : some description
 */

class Students{

}
public class MyArraysList {
    public int[] elem;
//    public Students elem0;
    public int usedSize;
    public static final int capacity = 10;

    public MyArraysList(){
        this.elem = new int[capacity];
        this.usedSize = 0;//计数器
    }

    //接口实现，

    //打印顺序表
    public void display(){
        for(int i = 0;i<this.usedSize;i++){

            //顺序表和数组的区别就在这。

            System.out.print(this.elem[i] + " ");
        }//1

//        System.out.println(Arrays.toString(this.elem));//2
        System.out.println();
    }

    //***

    //判断是不是满了
    private boolean isFull(){
        return this.elem.length == this.usedSize;
    }

    //在pos位置上新增元素
    public void add(int pos,int data){

        //先判断是不是满了，在判断其合法性。

        //判断数组是不是满了
        if(isFull()){
            System.out.println("满了需要，扩容");
//            Arrays.copyOf(elem,2*capacity);
            this.elem = Arrays.copyOf(this.elem,2*this.elem.length);
            System.out.println("扩容成功");
        }
        //判断是不是其合法性
        if(pos<0||pos>this.usedSize) {//pos>this.usedSize??，虽然usesSize位置处没有元素，但也可以添加元素的。
            System.out.println("请输入合适的pos值");
            return;
        }
        //添加和移位
        for(int i = this.usedSize-1;i>=pos;i--){
            elem[i+1] = elem[i];
        }

        //添加
        this.elem[pos] = data;
        this.usedSize++;//忘记了！！
    }
//判断是否包含某个元素
    public boolean contains(int toFind){
        for(int i = 0;i<this.usedSize;i++){
            if(elem[i] == toFind){
           return true ;
            }
         }
        return false;
    }
    //查找某一元素的对应位置
    public int search(int toFind){
        for(int i = 0;i<this.usedSize;i++){
            if(this.elem[i] == toFind){
                return i;
            }
        }
        return -1;
    }
    private void checkPos(int pos){
        if(pos<0 || pos>=this.usedSize ){
            throw new RuntimeException("pos位置不合法");
        }
    }

    //获取pos位置的元素
    public int getPos(int pos){
        //顺序表是否为空
        if(this.usedSize == 0){
            throw new RuntimeException("顺序表为null");
        }
            //if(this.elem.length == 0||this.elem == null) return -1;
        //在初始化的时候，已经开辟内存了。不存在elem是不是null。
        //判断合法性
        if(pos<0 || pos>=this.usedSize)
        {
            throw new RuntimeException("pos位置不合法");

        }

        return elem[pos];
    }


    //给pos位置的元素设置为value
    public void setPos(int pos,int value){
        if(pos<0 || pos >=this.usedSize){
            throw new RuntimeException("pos位置不合法");
        }

        this.elem[pos] = value;
    }



    //向前移位
    public void toMoveForward(int pos){
        if(pos == this.usedSize){
            usedSize--;
        }
        for(int i = pos;i<this.usedSize-1;i++){
            this.elem[i] = this.elem[i+1];
        }
    }
    //删除第一次出现的关键字key，也只能删除第一次出现的。
    public void remove(int toRemove){
       //1.先找到toRemove的位置
        //2. 在向前移动元素。
       int i = search(toRemove);
       if(i<0) {
           System.out.println("没有要删除的数字");
           return;
       }
        for(int j = i ;j<this.usedSize-1;j++){
            this.elem[j] = this.elem[j+1];
        }
        this.usedSize--;
    }

    //获取顺序表的长度
    public int size(){
        return this.usedSize;
    }


    //清空顺序表
    public void clear(){

        this.usedSize = 0;
    }

}

```

