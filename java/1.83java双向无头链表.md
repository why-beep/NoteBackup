java数据结构 --双向无头链表







* image

<img src="D:\java学习\image\双向无头链表图.png" style="zoom:50%;" />



* 创建

```java
class Node {
    public int data;
    public Node next;
    public Node perv;
    
    public Node(int data) {
        this.data = data;
    }
}
public class MyLinkedList {
    public Node head;//标志头节点
    public Node tail;//标志尾巴
    
    //方法
}
```





初学的常见的错误，使用while(cur != null) { //忘记了cur = cur.next; }



> 任何节点的插入先绑定，插入节点的后面





* 头插法

```java
public void addFirst(int data) {
    Node node = new Node(data);
    if(this.head == null) {
        this.head = node;
        this.tail = node;
    }else{
        node.next = this.head;
        this.head.perv = node;
        this.head = node;
    }
}
```



* 打印

```java
public void display() {
    if(this.head == null) return;
    Node cur = this.head;
    
    while(cur != null) {
        System.out.print(cur.data + " ");
        cur = cur.next;
    }
    System.out.println();
}
```



* 尾插法

```java
public void addLast(int data) {
    Node node = new Node(data);
    if(this.head == null){
        this.head = node;
        this.tail = node;
    }else{
        node.perv = this.tail;
        this.tail.next = node;
        this.tail = node;
    }
}
```



* 查找关键字key是否在双向链表中

```java
public boolean contains(int key) {
    Node cur = this.head;
    
    while(cur != null) {
        if(cur.data == key) {
            return true;
        }
        cur = cur.next;
    }
    return false;
}
```



* 双向链表的长度

```java
public int size() {
    Node cur = this.head;
    int count = 0;
    
    while(cur != null){
        count++;
        cut = cur.next;
    }
    return count;
}
```



* 在任意位置插入data

```java
public void checkIndex(int index) {
    if(index <0 || index >size()) {
        throw new RuntimeExpection("index不合法");
    }
}
public Node searchIndex(int index) {
    Node cur = this.head;
    while(index != 0) {
        cur = cur.next;
        index--;
    }
    return cur;
}
public void addIndex(int index,int data) {
    //判断合法性
    checkIndex(index);
    //找到index的下标位置。
    
    if(index == 0) {
        addFirst(data);
        return;
    }
    if(index == size()){
        addLast(data);
        return;
    }
    Node node = new Node(data);
    Node cur = searchIndex(index);
    
    cur.perv.next = node;
    node.perv = cur.perv;
    node.next = cur;
    cur.perv = node;
    
}
```



* 删除第一次出现的元素

  

```java
public void remove(int key) {
   if(this.head == null) return;
    Node cur = this.head;
     if(this.head.data == key) {
        this.head = this.head.next;
        this.head.perv = null;
         cur.next = null;
         return;
    }
    
    while(cur != null) {
        if(cur.data == key){
            if(cur == this.tail){//注意this.tail节点
                this.tail = this.tail.perv;
                this.tail.next = null;
                cur.perv = null;
                return;
            }
        cur.perv.next = cur.next;
        cur.next.perv = cur.perv;
            cur.next = null;
            cur.perv = null;
            return;
        }else{
             cur = cur.next;
        }
        
       
    }
}
```



* 删除所有符合标准的节点

err的

```java
public void removeAllKey(int key) {
    if(this.head == null) return;
    Node cur = this.head;
   
    while(this.head.data == key) {
        this.head = this.head.next;
        this.head.perv = null;
        cur.next = null;
        cur = this.head;
    }
    //到这的话，不出意外的话，head所指向的节点一定不是null
    while(cur != null) {
        if(cur.data == key) {
            if(cur == this.tail){
                this.tail = this.tail.perv;
                cur.perv = null;
                this.tail.next = null;
            }
            cur.perv.next = cur.next;
            cur.next.perv = cur.perv;
            cur.perv = null;
            cur.next = null;
        }else{
            cur = cur.next;
        }
    }
}
```

* 

* ```java
  public void removeAllKey(int key) {
          if(this.head == null) return;
          Node cur = this.head;
          while(cur.data == key){
              this.head = this.head.next;
              this.head.perv = null;
              cur = cur.next;
          }
          while(cur != null) {
              if(cur.data == key){
  //                还有tail
                  if(cur == this.tail){
                      this.tail.perv.next = null;
                      this.tail = this.tail.perv;
                  }
  //                    cur.next.perv = cur.perv;
                      cur.perv.next = cur.next;
                  if(cur.next != null) {
                      cur.next.perv = cur.perv;
                  }
  
                      cur = cur.next;
  
              }else{
                  cur = cur.next;
              }
          }
      }
  
  ```

  









```
public class MyLinkedList {
    public void removeAllKey(int key) {
        if(this.head == null) return;
        Node cur = this.head;
        while(cur.data == key){
            this.head = this.head.next;
            this.head.perv = null;
            cur = cur.next;
        }
        while(cur != null) {
            if(cur.data == key){
//                还有tail
                if(cur == this.tail){
                    this.tail.perv.next = null;
                    this.tail = this.tail.perv;
                }
//                    cur.next.perv = cur.perv;
                    cur.perv.next = cur.next;
                if(cur.next != null) {
                    cur.next.perv = cur.perv;
                }
                    cur = cur.next;

            }else{
                cur = cur.next;
            }
        }
    }
    public void displayHead(){
        System.out.print(head.data + " ");
        System.out.println();
    }

    public void clear() {
        while(this.head != null) {
            Node cur = this.head.next;
            this.head.next = null;
            this.head.perv = null;
            this.head = cur;
        }
        this.tail = null;
//        this.tail.perv = null;为啥不是这句呢？无法debuger
    }


}

```

