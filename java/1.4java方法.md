方法

相当于C语言中的”函数“，

方法，避免代码的重复利用，

main()方法，也是方法，



* 方法的书写

```java
public static 返回值 方法名( 形参列表){
    //方法体
}
public static void maxNum(int n1,int n2){
    return n1>n2?n1:n2;
}
public static void main(String[] args){
    int a = 10;
    int b = 20;
    System.out.println(maxNum(a,b));
    
}
```

> 方法名：采用小驼峰的形式。maxNum
>
> 返回值可有可无，具体看业务需求。
>
> 如果有返回值，那么  返回值的类型需要和方法的返回值类型匹配。



> ```java
> System.out.println(maxNum(a,b));//有返回值的时候可以这样写
> 
> System.out.println(maxNum(a,b));//返回值是void的时候会报错。
> ```
>
> 

> 调用方法时，不用专门放到mian()前，不像C语言那样，需要事先声明，



> 局部变量，在栈上开辟。
>
> 局部变量，就是main()方法中的`a`,`b`;maxNum()方法中的`n1`,`n2`.
>
> 



> java中只有按值传递，没有按地址传递，
>
> 即使在引用的时候，传递的也是值，创建的也是形参。



> return 表示**方法**的结束，方法下面的代码，将不会被执行了。





* 实参和形参的关系（**）

//交换两个整数变量。

在java中，参数的传递只有按值传递，没有像C语言中的按地址传递参数。

在java中，要实现的话，用到**类**和**对象**来实现，**数组**也可以。

```java
public static void swap(int[] arr){
        int tmp = arr[0];
        arr[0] = arr[1];
        arr[1] = tmp;
}
public static void main(String[] args) {
        //实现的两个整型的交换。

        int[] arr = {10,20};
        swap(arr);
        System.out.println(arr[0] +"" + arr[1]);
}
```

```java
//思考怎样把数据传递到数组中
// arr[0] = 10;//??  

int[] arr1 = {0,0};
arr1[0] = 100;
arr1[1] = 200;
System.out.println(arr1[0] + " " + arr1[1]);
//数组必须，填进元素才能，通过相应的下标使用。
//不能通过初始化。来使用。
//但是[]内，不用
```



##### 方法的重载 -- overload

有些时候我们需要用一个函数同时兼容多种参数的情况，我们就可以使用到方法重载。

就是方法名，可以相同的，比如，计数器。

> 1. 方法名相同
> 2. 返回值不作要求。
> 3. 参数列表不同（参数的个数  或  参数的类型  不同）
>
> 4. **同一个类**当中。
>
> 面试题：
>
> ​      重载和重写的区别是什么？

```java
public static int sum(int a,int b){
    return a + b;
}
public static int sum(int a,int b,int c){
    return a + b + c;
}
public static double (double a ,double b){
    return a + b;
}
//思考：手机中的计算器，多个加法运算，怎么计算？
```





###### 递归

函数的调用  是要在栈上开辟内存的，给这个函数开辟栈帧。

栈：这种数据结构，是先进后出。

递归的函数，就是在栈上的。

递归：把一个大的问题 化解小的问题，化为公式。

1. 调用自己本身。
2. 有一个趋近终止的条件。
3. 推导出 递归的公式：

递归，有两个过程，去的过程，和 回的过程。
$$
if(boolean){
        \\return 1;//最后的递，归的开始。
}
\\return     \  n+ func(n);//就是公式块
$$

> 横向思考。不要试图走进 递归的纵向执行。因为，一些递归太过于深入了。
>
> 假设，

> 栈的空间大小： 1M/2M大小。





单路递归：阶乘，

多路递归：斐波那契数列：

```java
   public static int func(int n){  
    if(n ==1||n==2){
         return 1;
    }
   return func(n-1) + func(n-2);
}
//两个func()方法。
//二叉树
```

> 数据结构：二叉树；     多路递归   
>
> 数据结构:          栈；     单路递归





> 什么二叉树的遍历条件：三种，前*遍历、中 ，后\*遍历.





