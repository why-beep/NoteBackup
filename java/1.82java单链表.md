### 1.8数据结构2.0——单链表





* 顺序表的缺点：

  顺序表在中间或头部插入数据，时间复杂度为O(N).

  增容需要申请新空间，拷贝数据，释放旧空间。会有不小的损耗。

  增容一般需要两倍的空间增长，有一定的空间浪费。

> 思考：
>
> 数组和链表有什么区别？



> 顺序表：空间连续、支持随机访问
>
> 中间或前面部分的插入删除时间复杂度O(N) .2.增容的代价比较大。
>
> 链表：以节点为单位存储，不支持随机访问
>
> 头插法插入时间复杂度为O(N) , 尾插法时间复杂度是O(N),插入一个开辟一个空间。

  

> 两者等价  ArrayList and LinkedList   区别

> 链表能做到，随取随用。



链表：一种**物理存储结构**上非连续的存储结构，数据元素的逻辑顺序是通过链表中的**引用链接**次序实现的。

* 单链表分为

单向    双向

带头  不带头

循环    非循环  

一共8种，只讲 **不带头单向非循环** 、 **不带头双向非循环**。

1. 不带头节点的单向非循环链表
2. 带头的单项非循环的链表
3. 带头的单线循环链表



单链表由节点组成，分为**数值域**和**下一个节点的引用**，

data域 和next域

<img src="D:\java学习\image\链表的节点.png" style="zoom:50%;" />







***

* 不带头节点的单向非循环链表

<img src="D:\java学习\image\不带头节点的单向非循环链表.png" style="zoom:50%;" />

> 不带头节点的链表，head可以随便换，
>
> 相当于无头蛇。

* 带头节点的单项非循环链表

<img src="D:\java学习\image\带头节点的单向非循环链表.png" style="zoom:50%;" />

> 头节点不可以，换，头节点没有数值域，

* 带头节点的单向循环链表

<img src="D:\java学习\image\带头节点的单向循环链表.png" style="zoom:50%;" />

> 最后一个节点的指针域，指向的是头节点的下一个节点的指针域。





> 一个节点一个对象。包含数据和next域。







#### 单链表的注意事项

1. MyLinkedList

```java
class Node{
    public int val;
    public Node next;//这一条的使用，有些迷惑，不是还没创建完类吗？？
    
    public Node(int val){
        this.val = val;
    }
}
public class MyLinkedList{
    public sta
}


```





* 使用穷举法创建的单链表

<img src="D:\java学习\image\使用穷举法创建的单链表.png" style="zoom:50%;" />



* 创建单链表开辟的内存区域

```java
 public void creatLinked(){

        Node node1 = new Node(1);
        Node node2 = new Node(2);
        Node node3 = new Node(3);
        Node node4 = new Node(4);
        Node node5 = new Node(5);

        node1.next = node2;
        node2.next = node3;
        node3.next = node4;
        node4.next = node5;
        this.head = node1;

    }
//在执行代码的过程中，使用Node声明的node1-5,因为创建在栈上，会在执行完后，被销毁。
//this.head  不会使用的类创建的变量。在堆上，
```

#####   

* 在TestDemo中引用单链表

<img src="D:\java学习\image\在TestDemo中引用单链表。.png" style="zoom:50%;" />



##### 单链表的接口

```java
class Node {
    public int data;
    public Node next;
    
    public Node(int data){
        this.data = data;
    }
}
public class MyLinkedList{
    public Node head;
}
```



* display（）

```java
public void display(){
    ListNode cur = this.head;
    while(this.cur != null){
        sout(cur.val + " ");
        cur = cur.next;
    }
}
```

* 头插法

  ```java
  public void addFirst(int data){
      Node node = new Node(data);
      node.next = this.head;
      this.head = node;
  }
  ```

  

  ###### 尾插法

     时间复杂度是O(N)。

  ```java
  public void addLast(int data){
      Node node = new Node(data);
      if(this.head == null){
          this.head = node;
      }else{
      Node cur = this.head;
        while(cur.next != null){
          cur = cur.next;
        }
      cur.next = node;
      }
  }
  ```

  

* 在index位置上插入key

  ```java
  public Node findIndex(int index){
      Node cur = this.head;
      while(index-1 != 0){
          cur = cur.next;
          index--;
      }
      return cur;
  }
  public void addIndex(int index,int data){
      //判断合法性
      if(index<0 || index >size()){
          sout("输入正确的数字！");
          return;
      }
     if(index == 0){
         addFirst(data);
         return;
     }
      if(index == size()){
          addLast(data);
          return;
      }
        Node cur = findIndex(index);
        Node node = new Node(data);
          node.next = cur.next;
          cur.next = node;
  }
  ```
  
  

* 查找是否包含关键字key

  ```java
  public boolean contains(int key){
      Node cur = this.head;
      while(cur != null){//不是cur.next != null
          if(cur.data == key){
              return true;
          }
      }
      return false;
  }
  ```

  

* 删除第一次出现key的节点。

  ```java
  public Node searchPerv(int key){
      Node cur = this.head;
      while(cur.next != null){
          if(cur.next.data ==key){
              return cur;
          }
          cur = cur.next;
      }
      return null;
  }
  public void remove(int key){
      if(this.head == null) {
          sout("");
          return;
      }
      if(this.head.data ==key){
          this.head = this.head.next;
          return;
      }
     Node cur = searchPerv(key);
      if(cur ==null){
          sout("找不到");
          return;
      }
      Node del = cur.next;
      cur.next =del.next;
      
  }
  ```

  

* 删除所有的key节点（一次遍历）

  ```java
  public Node removeAllKey(int key){
      //判断null
      if(this.head ==null){
          sout("diu");
          return null;
      }
      Node per = this.head;
      Node cur = this.head.next;
      while(cur != null){
          if(cur.data == key){
              per.next = cur.next;
              cur = cur.next;
          }else{
              per = cur;
              cur = cur.next;
          }
      }
      if(this.head.data == key){
          this.head = per;
      }
      return this.head;
  }
  ```

  

* 得到长度

  ```java
  public int size(){
      int count = 0;
      Node cur = this.head;
      while(cur != null){
          count++;
          cur = cur.next;
      }
      return count;
  }
  ```

  

* 全部删除

  ```java
  public void clear(){
      //this.head = null;
   
      while(this.head != null){
         Node nodeNext = this.head.next;
          this.head.next = null;
          this.head = nodeNext;
      }
  }
  ```

  



注意

```java
class Node{
    public int data;
    public Node next;
    
    public Node(int data){
        this.data = data;
    }
}
```



> 节点才有data，和next，next是引用，不是下一个节点，是下一个节点的地址，虽然形式上一样。









#### 力扣刷题



快慢指针，（两步走——一步走，

哨兵节点。

cur 指向的位置变化。
